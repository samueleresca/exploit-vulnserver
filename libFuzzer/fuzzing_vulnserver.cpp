// vulnserver_fuzzer.cpp
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>

// Mock functions to simulate the vulnerable functions
void Function1(char* Input) {
    char Buffer2S[140];
    strcpy(Buffer2S, Input);
}

void Function2(char* Input) {
    char Buffer2S[60];
    strcpy(Buffer2S, Input);
}

void Function3(char* Input) {
    char Buffer2S[2000];
    strcpy(Buffer2S, Input);
}

void Function4(char* Input) {
    char Buffer2S[1000];
    strcpy(Buffer2S, Input);
}

// Helper function to process commands like the original
void ProcessCommand(const char* input, size_t size) {
    if (size < 4) return;  // Too short to be valid command
    
    char* buf = (char*)malloc(size + 1);
    memcpy(buf, input, size);
    buf[size] = '\0';
    
    if (strncmp(buf, "TRUN ", 5) == 0) {
        // Test TRUN command which uses Function3
        Function3(buf);
    }
    else if (strncmp(buf, "GTER ", 5) == 0) {
        // Test GTER command which uses Function1
        Function1(buf);
    }
    else if (strncmp(buf, "KSTET ", 6) == 0) {
        // Test KSTET command which uses Function2
        Function2(buf);
    }
    else if (strncmp(buf, "HTER ", 5) == 0) {
        // Test HTER command which uses Function4
        Function4(buf);
    }
    
    free(buf);
}

// LibFuzzer entry point
extern "C" int LLVMFuzzerTestOneInput(const uint8_t* Data, size_t Size) {
    // Ensure we have enough data for a command
    if (Size < 5) return 0;
    
    // Create space for null-terminated string
    char* input = (char*)malloc(Size + 1);
    memcpy(input, Data, Size);
    input[Size] = '\0';
    
    // Process the fuzz input
    ProcessCommand(input, Size);
    
    free(input);
    return 0;
}